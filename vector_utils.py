"""
vector_utils.py – Feature Vector Handling with Qdrant

Author: Mohammed Faris Sait

This module provides utility functions for:
 Computing feature vectors from image frames using grayscale flattening
 Connecting to and interacting with the Qdrant vector database
 Creating and managing a vector collection (if not already existing)
 Inserting frame vectors into the database with image path payloads
 Performing similarity search for top-k closest frames
 Counting the number of stored vectors (optional monitoring)

Qdrant is used as the backend vector search engine, and each frame's vector is stored along with its image path.
Feature vectors are generated by resizing the image to 64x64 grayscale and flattening the pixel values.
"""
import os
import uuid
import cv2
import numpy as np
from dotenv import load_dotenv
from qdrant_client import QdrantClient
from qdrant_client.http.models import Distance, VectorParams, PointStruct

# Load environment variables
load_dotenv()
QDRANT_URL = os.getenv("QDRANT_URL")
QDRANT_API_KEY = os.getenv("QDRANT_API_KEY")
COLLECTION_NAME = "video_frames"

# Connect to Qdrant
client = QdrantClient(url=QDRANT_URL, api_key=QDRANT_API_KEY)

# Only create collection if it doesn't exist (avoid wiping data)
if not client.collection_exists(collection_name=COLLECTION_NAME):
    client.create_collection(
        collection_name=COLLECTION_NAME,
        vectors_config=VectorParams(size=4096, distance=Distance.COSINE),
    )

def compute_feature_vector(image_path):
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError(f"Image load failed: {image_path}")
    img_resized = cv2.resize(img, (64, 64))
    return img_resized.flatten().astype(np.float32) / 255.0

def add_to_db(image_path):
    vector = compute_feature_vector(image_path)
    point_id = str(uuid.uuid4())
    client.upsert(
        collection_name=COLLECTION_NAME,
        points=[PointStruct(id=point_id, vector=vector.tolist(), payload={"path": image_path})]
    )
    print(f" Vector inserted to Qdrant: {image_path} → Vector size: {len(vector)}")

def search_similar(query_vector, top_k=5):
    search_result = client.search(
        collection_name=COLLECTION_NAME,
        query_vector=query_vector.tolist(),
        limit=top_k,
        with_payload=True,
    )
    return [(hit.payload["path"], hit.score) for hit in search_result]

def count_vectors():
    return client.count(collection_name=COLLECTION_NAME).count
